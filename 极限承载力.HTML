<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>螺旋桩极限承载力计算器</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #1a6bc3 0%, #0d4d9c 100%);
            color: white;
            padding: 25px 30px;
            text-align: center;
        }
        
        header h1 {
            font-size: 28px;
            margin-bottom: 8px;
        }
        
        header p {
            font-size: 16px;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .navigation {
            display: flex;
            justify-content: center;
            background-color: #f0f5ff;
            border-bottom: 1px solid #eaeef5;
        }
        
        .nav-btn {
            padding: 15px 30px;
            background: none;
            border: none;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }
        
        .nav-btn:hover {
            color: #1a6bc3;
            background-color: #e8f1ff;
        }
        
        .nav-btn.active {
            color: #1a6bc3;
            border-bottom: 3px solid #1a6bc3;
            background-color: #e8f1ff;
        }
        
        .page {
            padding: 30px;
            min-height: 600px;
        }
        
        .hidden {
            display: none;
        }
        
        .section {
            margin-bottom: 30px;
        }
        
        .section-title {
            font-size: 20px;
            color: #2c3e50;
            padding-bottom: 12px;
            margin-bottom: 20px;
            border-bottom: 2px solid #eaeef5;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section-title i {
            color: #1a6bc3;
        }
        
        .input-group {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .input-row {
            display: flex;
            flex-direction: column;
        }
        
        .input-row label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #444;
            font-size: 14px;
        }
        
        .input-row input, .input-row select {
            padding: 12px 15px;
            border: 1px solid #d1d9e6;
            border-radius: 6px;
            font-size: 15px;
            transition: border 0.3s;
        }
        
        .input-row input:focus, .input-row select:focus {
            outline: none;
            border-color: #1a6bc3;
            box-shadow: 0 0 0 2px rgba(26, 107, 195, 0.2);
        }
        
        .soil-layers-container {
            margin-top: 15px;
        }
        
        .soil-layer {
            background-color: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #eaeef5;
        }
        
        .soil-layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px dashed #d1d9e6;
        }
        
        .soil-layer-title {
            font-weight: 600;
            color: #1a6bc3;
        }
        
        .remove-layer {
            background-color: #ff6b6b;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .remove-layer:hover {
            background-color: #ff5252;
        }
        
        .blade-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .blade-input-group {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 6px;
        }
        
        .method-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .method-card {
            background-color: white;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
            border: 1px solid #eaeef5;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .method-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.12);
            border-color: #1a6bc3;
        }
        
        .method-card.selected {
            border-color: #1a6bc3;
            background-color: #e8f1ff;
            box-shadow: 0 5px 15px rgba(26, 107, 195, 0.15);
        }
        
        .method-card h3 {
            font-size: 18px;
            color: #1a6bc3;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .method-card p {
            color: #666;
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .method-card .btn {
            margin-top: 10px;
        }
        
        .results-container {
            background-color: #f8fafc;
            padding: 25px;
            border-radius: 8px;
            margin-top: 30px;
            border: 1px solid #eaeef5;
        }
        
        .results-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .results-title i {
            color: #2ecc71;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .result-item {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
        }
        
        .result-item h4 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #444;
        }
        
        .result-value {
            font-size: 28px;
            font-weight: 700;
            color: #1a6bc3;
        }
        
        .result-unit {
            font-size: 16px;
            color: #666;
            margin-left: 5px;
        }
        
        .result-details {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
        
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background-color: #1a6bc3;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #0d4d9c;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(26, 107, 195, 0.3);
        }
        
        .btn-secondary {
            background-color: #f0f5ff;
            color: #1a6bc3;
            border: 1px solid #d1d9e6;
        }
        
        .btn-secondary:hover {
            background-color: #e8f1ff;
        }
        
        .btn-success {
            background-color: #2ecc71;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #27ae60;
        }
        
        .btn-calculate-all {
            background-color: #9b59b6;
            color: white;
            margin-top: 20px;
            width: 100%;
            justify-content: center;
        }
        
        .btn-calculate-all:hover {
            background-color: #8e44ad;
        }
        
        .buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
        }
        
        .add-layer-btn, .add-blade-btn {
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .add-layer-btn:hover, .add-blade-btn:hover {
            background-color: #27ae60;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(26, 107, 195, 0.3);
            border-radius: 50%;
            border-top-color: #1a6bc3;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .footer {
            text-align: center;
            padding: 20px;
            color: #777;
            font-size: 14px;
            border-top: 1px solid #eaeef5;
            margin-top: 30px;
        }
        
        .calculation-progress {
            margin: 20px 0;
            padding: 15px;
            background-color: #f0f7ff;
            border-radius: 8px;
            border-left: 4px solid #1a6bc3;
        }
        
        .progress-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
            background-color: white;
        }
        
        .progress-item.completed {
            color: #2ecc71;
        }
        
        .progress-item.running {
            color: #1a6bc3;
        }
        
        .progress-item.pending {
            color: #999;
        }
        
        .all-results {
            margin-top: 30px;
        }
        
        .method-result-card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #eaeef5;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
        }
        
        .method-result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eaeef5;
        }
        
        .method-result-title {
            font-size: 18px;
            font-weight: 600;
            color: #1a6bc3;
        }
        
        @media (max-width: 768px) {
            .input-group {
                grid-template-columns: 1fr;
            }
            
            .method-list {
                grid-template-columns: 1fr;
            }
            
            .results-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-calculator"></i> 螺旋桩极限承载力计算器</h1>
            <p>集成五种不同规范的螺旋桩极限承载力计算方法，共用一套输入参数，保持原始计算逻辑</p>
        </header>
        
        <div class="navigation">
            <button class="nav-btn active" id="nav-input">参数输入</button>
            <button class="nav-btn" id="nav-methods">计算方法</button>
            <button class="nav-btn" id="nav-results">计算结果</button>
        </div>
        
        <!-- 参数输入页面 -->
        <div id="page-input" class="page">
            <div class="section">
                <h2 class="section-title"><i class="fas fa-cog"></i> 桩参数设置</h2>
                <div class="input-group">
                    <div class="input-row">
                        <label for="pile-n">叶片数量</label>
                        <input type="number" id="pile-n" min="1" max="10" value="3">
                    </div>
                    <div class="input-row">
                        <label for="pile-Ds">桩杆直径 Ds (m)</label>
                        <input type="number" id="pile-Ds" step="0.001" value="0.254">
                    </div>
                    <div class="input-row">
                        <label for="pile-Sh">叶片间距 Sh (m)</label>
                        <input type="number" id="pile-Sh" step="0.001" value="1.144">
                    </div>
                    <div class="input-row">
                        <label for="pile-L">螺旋桩总埋深 L (m)</label>
                        <input type="number" id="pile-L" step="0.001" value="7">
                    </div>
                    <div class="input-row">
                        <label for="pile-Hh_bot">最底部叶片距桩底距离 (m)</label>
                        <input type="number" id="pile-Hh_bot" step="0.001" value="0">
                    </div>
                    <div class="input-row">
                        <label for="pile-phi_pile_deg">桩的倾斜角 (°)</label>
                        <input type="number" id="pile-phi_pile_deg" step="0.1" value="0">
                    </div>
                </div>
                
                <h3 style="margin-top: 20px; margin-bottom: 10px;">叶片直径设置 (从上到下)</h3>
                <div id="blade-inputs" class="blade-inputs">
                    <!-- 动态生成叶片直径输入框 -->
                </div>
                <button id="add-blade" class="add-blade-btn"><i class="fas fa-plus"></i> 添加叶片直径</button>
            </div>
            
            <div class="section">
                <h2 class="section-title"><i class="fas fa-layer-group"></i> 土层参数设置</h2>
                <div class="input-group">
                    <div class="input-row">
                        <label>土层数量</label>
                        <input type="number" id="layer-count" min="1" max="10" value="4">
                    </div>
                </div>
                
                <div id="soil-layers" class="soil-layers-container">
                    <!-- 动态生成土层输入框 -->
                </div>
                <button id="add-layer" class="add-layer-btn"><i class="fas fa-plus"></i> 添加土层</button>
            </div>
            
            <div class="buttons">
                <button id="save-params" class="btn btn-primary">
                    <i class="fas fa-save"></i> 保存参数并选择计算方法
                </button>
                <button id="reset-params" class="btn btn-secondary">
                    <i class="fas fa-redo"></i> 重置参数
                </button>
            </div>
        </div>
        
        <!-- 计算方法选择页面 -->
        <div id="page-methods" class="page hidden">
            <div class="section">
                <h2 class="section-title"><i class="fas fa-list-ol"></i> 选择计算方法</h2>
                <p style="margin-bottom: 20px; color: #666;">以下五种计算方法将使用您刚才输入的同一套桩参数和土层参数进行计算。可以单选或全选进行计算。</p>
                
                <div class="method-list">
                    <div class="method-card" data-method="1">
                        <h3><i class="fas fa-bolt"></i> 方法一：架空输电线路螺旋锚基础设计规范</h3>
                        <p>适用于输电线路螺旋锚基础设计，考虑了多层土和不同叶片直径，计算抗拉和抗压承载力。</p>
                        <div class="input-row" style="margin-top: 10px;">
                            <label style="font-weight: normal;">
                                <input type="checkbox" class="method-checkbox" data-method="1" checked> 选择此方法
                            </label>
                        </div>
                    </div>
                    
                    <div class="method-card" data-method="2">
                        <h3><i class="fas fa-tower-cell"></i> 方法二：架空输电线路基础设计规程</h3>
                        <p>2023版架空输电线路基础设计规程，适用于浅埋和深埋锚盘，考虑土体破坏模式。</p>
                        <div class="input-row" style="margin-top: 10px;">
                            <label style="font-weight: normal;">
                                <input type="checkbox" class="method-checkbox" data-method="2" checked> 选择此方法
                            </label>
                        </div>
                    </div>
                    
                    <div class="method-card" data-method="3">
                        <h3><i class="fas fa-solar-panel"></i> 方法三：太阳能发电站支架基础技术规范</h3>
                        <p>适用于太阳能发电站支架基础，采用离散积分方法计算侧阻力，考虑抗拔系数。</p>
                        <div class="input-row" style="margin-top: 10px;">
                            <label style="font-weight: normal;">
                                <input type="checkbox" class="method-checkbox" data-method="3" checked> 选择此方法
                            </label>
                        </div>
                    </div>
                    
                    <div class="method-card" data-method="4">
                        <h3><i class="fas fa-globe-americas"></i> 方法四：Chance Technical Design Manual</h3>
                        <p>国际通用的螺旋桩设计手册，区分黏土和砂土，考虑侧摩阻力和安装深度影响。</p>
                        <div class="input-row" style="margin-top: 10px;">
                            <label style="font-weight: normal;">
                                <input type="checkbox" class="method-checkbox" data-method="4" checked> 选择此方法
                            </label>
                        </div>
                    </div>
                    
                    <div class="method-card" data-method="5">
                        <h3><i class="fas fa-flag"></i> 方法五：IPENZ Practice Note 28</h3>
                        <p>新西兰螺旋桩设计实践指南，区分单独承载和圆柱剪切模式，考虑土体类型和水平地应力。</p>
                        <div class="input-row" style="margin-top: 10px;">
                            <label style="font-weight: normal;">
                                <input type="checkbox" class="method-checkbox" data-method="5" checked> 选择此方法
                            </label>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <button id="select-all-methods" class="btn btn-secondary">
                        <i class="fas fa-check-square"></i> 全选所有方法
                    </button>
                    <button id="deselect-all-methods" class="btn btn-secondary">
                        <i class="fas fa-square"></i> 取消全选
                    </button>
                </div>
                
                <button id="calculate-selected" class="btn btn-calculate-all">
                    <i class="fas fa-calculator"></i> 计算选定方法
                </button>
                
                <div class="buttons">
                    <button id="back-to-input" class="btn btn-secondary">
                        <i class="fas fa-arrow-left"></i> 返回修改参数
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 计算结果页面 -->
        <div id="page-results" class="page hidden">
            <div class="section">
                <h2 class="section-title"><i class="fas fa-chart-line"></i> 计算结果</h2>
                
                <div id="calculation-progress" class="calculation-progress hidden">
                    <h4 style="color: #1a6bc3; margin-bottom: 15px;">计算进度</h4>
                    <div id="progress-items">
                        <!-- 进度项将动态生成 -->
                    </div>
                </div>
                
                <div id="all-results" class="all-results">
                    <!-- 所有方法的计算结果将动态显示在这里 -->
                </div>
                
                <div class="buttons">
                    <button id="back-to-methods" class="btn btn-secondary">
                        <i class="fas fa-arrow-left"></i> 返回方法选择
                    </button>
                    <button id="new-calculation" class="btn btn-primary">
                        <i class="fas fa-calculator"></i> 重新计算
                    </button>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>螺旋桩极限承载力计算器 &copy; 2023 | 集成五种计算方法 | 保持原始计算逻辑 | 仅供工程参考使用</p>
        </div>
    </div>

    <script>
        // 全局变量，存储输入参数和计算结果
        let pileParams = {};
        let soilLayers = [];
        let selectedMethods = [1, 2, 3, 4, 5]; // 默认全选
        let calculationResults = {};
        
        // 页面初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 初始化叶片直径输入框
            updateBladeInputs(3);
            
            // 初始化土层输入框
            updateSoilLayers(4);
            
            // 导航按钮事件 - 修复点击不跳转的问题
            document.getElementById('nav-input').addEventListener('click', function() {
                switchPage('input');
            });
            
            document.getElementById('nav-methods').addEventListener('click', function() {
                // 尝试保存参数，但不阻止跳转
                saveParameters();
                switchPage('methods');
            });
            
            document.getElementById('nav-results').addEventListener('click', function() {
                // 直接跳转到结果页面
                switchPage('results');
            });
            
            // 叶片数量变化事件
            document.getElementById('pile-n').addEventListener('change', function() {
                const bladeCount = parseInt(this.value);
                updateBladeInputs(bladeCount);
            });
            
            // 土层数量变化事件
            document.getElementById('layer-count').addEventListener('change', function() {
                const layerCount = parseInt(this.value);
                updateSoilLayers(layerCount);
            });
            
            // 添加叶片按钮事件
            document.getElementById('add-blade').addEventListener('click', function() {
                const bladeCount = parseInt(document.getElementById('pile-n').value) + 1;
                document.getElementById('pile-n').value = bladeCount;
                updateBladeInputs(bladeCount);
            });
            
            // 添加土层按钮事件
            document.getElementById('add-layer').addEventListener('click', function() {
                const layerCount = parseInt(document.getElementById('layer-count').value) + 1;
                document.getElementById('layer-count').value = layerCount;
                updateSoilLayers(layerCount);
            });
            
            // 保存参数按钮事件
            document.getElementById('save-params').addEventListener('click', function() {
                if (saveParameters()) {
                    switchPage('methods');
                }
            });
            
            // 重置参数按钮事件
            document.getElementById('reset-params').addEventListener('click', resetParameters);
            
            // 方法选择事件
            document.querySelectorAll('.method-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const methodId = parseInt(this.getAttribute('data-method'));
                    const card = this.closest('.method-card');
                    
                    if (this.checked) {
                        if (!selectedMethods.includes(methodId)) {
                            selectedMethods.push(methodId);
                        }
                        card.classList.add('selected');
                    } else {
                        selectedMethods = selectedMethods.filter(id => id !== methodId);
                        card.classList.remove('selected');
                    }
                    
                    console.log('当前选中的方法:', selectedMethods);
                });
            });
            
            // 全选按钮事件
            document.getElementById('select-all-methods').addEventListener('click', function() {
                selectedMethods = [1, 2, 3, 4, 5];
                document.querySelectorAll('.method-checkbox').forEach(checkbox => {
                    checkbox.checked = true;
                });
                document.querySelectorAll('.method-card').forEach(card => {
                    card.classList.add('selected');
                });
            });
            
            // 取消全选按钮事件
            document.getElementById('deselect-all-methods').addEventListener('click', function() {
                selectedMethods = [];
                document.querySelectorAll('.method-checkbox').forEach(checkbox => {
                    checkbox.checked = false;
                });
                document.querySelectorAll('.method-card').forEach(card => {
                    card.classList.remove('selected');
                });
            });
            
            // 计算选定方法按钮事件
            document.getElementById('calculate-selected').addEventListener('click', function() {
                if (selectedMethods.length === 0) {
                    alert('请至少选择一种计算方法');
                    return;
                }
                
                calculateSelectedMethods();
            });
            
            // 返回修改参数按钮事件
            document.getElementById('back-to-input').addEventListener('click', function() {
                switchPage('input');
            });
            
            // 返回方法选择按钮事件
            document.getElementById('back-to-methods').addEventListener('click', function() {
                switchPage('methods');
            });
            
            // 重新计算按钮事件
            document.getElementById('new-calculation').addEventListener('click', function() {
                switchPage('methods');
            });
            
            // 初始选中所有方法卡片
            document.querySelectorAll('.method-card').forEach(card => {
                card.classList.add('selected');
            });
        });
        
        // 更新叶片直径输入框
        function updateBladeInputs(count) {
            const container = document.getElementById('blade-inputs');
            container.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                const bladeDiv = document.createElement('div');
                bladeDiv.className = 'blade-input-group';
                bladeDiv.innerHTML = `
                    <label>叶片 ${i+1} 直径 Dh${i+1} (m)</label>
                    <input type="number" id="blade-Dh-${i}" step="0.001" value="${0.962 - i * 0.1}">
                `;
                container.appendChild(bladeDiv);
            }
        }
        
        // 更新土层参数输入框
        function updateSoilLayers(count) {
            const container = document.getElementById('soil-layers');
            container.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                const layerDiv = document.createElement('div');
                layerDiv.className = 'soil-layer';
                layerDiv.innerHTML = `
                    <div class="soil-layer-header">
                        <div class="soil-layer-title">土层 ${i+1}</div>
                        <button type="button" class="remove-layer" data-index="${i}">删除</button>
                    </div>
                    <div class="input-group">
                        <div class="input-row">
                            <label>顶部深度 (m)</label>
                            <input type="number" id="soil-depth-top-${i}" step="0.001" value="${i * 2}">
                        </div>
                        <div class="input-row">
                            <label>底部深度 (m)</label>
                            <input type="number" id="soil-depth-bottom-${i}" step="0.001" value="${(i+1) * 2}">
                        </div>
                        <div class="input-row">
                            <label>土的重度 γ (kN/m³)</label>
                            <input type="number" id="soil-gamma-${i}" step="0.1" value="${18 + i}">
                        </div>
                        <div class="input-row">
                            <label>粘聚力 c (kPa)</label>
                            <input type="number" id="soil-c-${i}" step="1" value="${10 + i * 10}">
                        </div>
                        <div class="input-row">
                            <label>内摩擦角 φ (°)</label>
                            <input type="number" id="soil-phi-${i}" step="0.1" value="${25 + i * 2}">
                        </div>
                        <div class="input-row">
                            <label>侧压力系数 ψ</label>
                            <input type="number" id="soil-psi-${i}" step="0.01" value="${0.4 + i * 0.05}">
                        </div>
                        <div class="input-row">
                            <label>影响系数 λ</label>
                            <input type="number" id="soil-lambda-${i}" step="0.1" value="${2.5 + i * 0.2}">
                        </div>
                        <div class="input-row">
                            <label>极限端阻力 qp (kPa)</label>
                            <input type="number" id="soil-qp-${i}" step="10" value="${800 + i * 200}">
                        </div>
                        <div class="input-row">
                            <label>抗拉侧摩阻力 qs_t (kPa)</label>
                            <input type="number" id="soil-qs_t-${i}" step="1" value="${10 + i * 5}">
                        </div>
                        <div class="input-row">
                            <label>抗压侧摩阻力 qs_c (kPa)</label>
                            <input type="number" id="soil-qs_c-${i}" step="1" value="${15 + i * 5}">
                        </div>
                        <div class="input-row">
                            <label>不排水抗剪强度 Cu (kPa)</label>
                            <input type="number" id="soil-Cu-${i}" step="1" value="${50 + i * 10}">
                        </div>
                        <div class="input-row">
                            <label>水平地应力系数 k</label>
                            <input type="number" id="soil-k-${i}" step="0.01" value="${0.5 + i * 0.05}">
                        </div>
                        <div class="input-row">
                            <label>土体类型</label>
                            <select id="soil-type-${i}">
                                <option value="clay">黏土</option>
                                <option value="sand" selected>砂土</option>
                                <option value="mixed">混合土</option>
                                <option value="silt">粉土</option>
                                <option value="rock">岩石</option>
                            </select>
                        </div>
                    </div>
                `;
                container.appendChild(layerDiv);
            }
            
            // 为删除按钮添加事件监听器
            document.querySelectorAll('.remove-layer').forEach(button => {
                button.addEventListener('click', function() {
                    const layerIndex = parseInt(this.getAttribute('data-index'));
                    removeSoilLayer(layerIndex);
                });
            });
        }
        
        // 删除土层
        function removeSoilLayer(layerIndex) {
            const layerCount = parseInt(document.getElementById('layer-count').value);
            if (layerCount > 1) {
                document.getElementById('layer-count').value = layerCount - 1;
                updateSoilLayers(layerCount - 1);
            } else {
                alert('至少需要一个土层');
            }
        }
        
        // 保存参数到全局变量
        function saveParameters() {
            try {
                // 保存桩参数
                pileParams = {
                    n: parseInt(document.getElementById('pile-n').value),
                    Ds: parseFloat(document.getElementById('pile-Ds').value),
                    Sh: parseFloat(document.getElementById('pile-Sh').value),
                    L: parseFloat(document.getElementById('pile-L').value),
                    Hh_bot: parseFloat(document.getElementById('pile-Hh_bot').value),
                    phi_pile_deg: parseFloat(document.getElementById('pile-phi_pile_deg').value)
                };
                
                // 获取叶片直径
                pileParams.Dh = [];
                for (let i = 0; i < pileParams.n; i++) {
                    pileParams.Dh.push(parseFloat(document.getElementById(`blade-Dh-${i}`).value));
                }
                
                // 保存土层参数
                const layerCount = parseInt(document.getElementById('layer-count').value);
                soilLayers = [];
                
                for (let i = 0; i < layerCount; i++) {
                    soilLayers.push({
                        depth_top: parseFloat(document.getElementById(`soil-depth-top-${i}`).value),
                        depth_bottom: parseFloat(document.getElementById(`soil-depth-bottom-${i}`).value),
                        gamma: parseFloat(document.getElementById(`soil-gamma-${i}`).value),
                        c: parseFloat(document.getElementById(`soil-c-${i}`).value),
                        phi: parseFloat(document.getElementById(`soil-phi-${i}`).value),
                        psi: parseFloat(document.getElementById(`soil-psi-${i}`).value),
                        lambda: parseFloat(document.getElementById(`soil-lambda-${i}`).value),
                        qp: parseFloat(document.getElementById(`soil-qp-${i}`).value),
                        qs_t: parseFloat(document.getElementById(`soil-qs_t-${i}`).value),
                        qs_c: parseFloat(document.getElementById(`soil-qs_c-${i}`).value),
                        Cu: parseFloat(document.getElementById(`soil-Cu-${i}`).value),
                        k: parseFloat(document.getElementById(`soil-k-${i}`).value),
                        soil_type: document.getElementById(`soil-type-${i}`).value
                    });
                }
                
                // 验证参数
                if (pileParams.n <= 0) {
                    alert('叶片数量必须大于0');
                    return false;
                }
                
                if (pileParams.Dh.length !== pileParams.n) {
                    alert('叶片直径数量必须等于叶片数量');
                    return false;
                }
                
                for (let i = 0; i < soilLayers.length; i++) {
                    if (soilLayers[i].depth_top >= soilLayers[i].depth_bottom) {
                        alert(`土层${i+1}的顶部深度必须小于底部深度`);
                        return false;
                    }
                }
                
                console.log('参数保存成功', { pileParams, soilLayers });
                return true;
                
            } catch (error) {
                alert('参数保存失败：' + error.message);
                return false;
            }
        }
        
        // 重置参数
        function resetParameters() {
            if (confirm('确定要重置所有参数吗？所有输入将被清除。')) {
                document.getElementById('pile-n').value = 3;
                document.getElementById('pile-Ds').value = 0.254;
                document.getElementById('pile-Sh').value = 1.144;
                document.getElementById('pile-L').value = 7;
                document.getElementById('pile-Hh_bot').value = 0;
                document.getElementById('pile-phi_pile_deg').value = 0;
                
                document.getElementById('layer-count').value = 4;
                
                updateBladeInputs(3);
                updateSoilLayers(4);
                
                pileParams = {};
                soilLayers = [];
                selectedMethods = [1, 2, 3, 4, 5];
                calculationResults = {};
                
                // 重置方法选择
                document.querySelectorAll('.method-checkbox').forEach(checkbox => {
                    checkbox.checked = true;
                });
                document.querySelectorAll('.method-card').forEach(card => {
                    card.classList.add('selected');
                });
                
                // 清空结果页面
                document.getElementById('all-results').innerHTML = '';
                
                alert('参数已重置为默认值');
            }
        }
        
        // 切换页面
        function switchPage(pageName) {
            // 更新导航按钮状态
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 隐藏所有页面
            document.querySelectorAll('.page').forEach(page => {
                page.classList.add('hidden');
            });
            
            // 显示目标页面
            document.getElementById(`page-${pageName}`).classList.remove('hidden');
            document.getElementById(`nav-${pageName}`).classList.add('active');
            
            // 如果切换到结果页面且有计算结果，显示结果
            if (pageName === 'results' && Object.keys(calculationResults).length > 0) {
                displayAllResults();
            }
        }
        
        // 计算选定的方法
        function calculateSelectedMethods() {
            // 确保参数已保存
            if (!pileParams.n || soilLayers.length === 0) {
                alert('请先保存参数');
                switchPage('input');
                return;
            }
            
            // 清空之前的结果
            calculationResults = {};
            
            // 显示进度条
            const progressContainer = document.getElementById('calculation-progress');
            const progressItems = document.getElementById('progress-items');
            progressContainer.classList.remove('hidden');
            progressItems.innerHTML = '';
            
            // 创建进度项
            const methodNames = {
                1: '方法一：架空输电线路螺旋锚基础设计规范',
                2: '方法二：架空输电线路基础设计规程',
                3: '方法三：太阳能发电站支架基础技术规范',
                4: '方法四：Chance Technical Design Manual',
                5: '方法五：IPENZ Practice Note 28'
            };
            
            selectedMethods.forEach(methodId => {
                const progressItem = document.createElement('div');
                progressItem.className = 'progress-item pending';
                progressItem.id = `progress-${methodId}`;
                progressItem.innerHTML = `
                    <i class="fas fa-circle"></i>
                    <span>${methodNames[methodId]} - 等待计算</span>
                `;
                progressItems.appendChild(progressItem);
            });
            
            // 切换到结果页面
            switchPage('results');
            
            // 开始计算（使用异步模拟计算过程）
            calculateMethodsSequentially(0);
        }
        
        // 顺序计算方法
        function calculateMethodsSequentially(index) {
            if (index >= selectedMethods.length) {
                // 所有方法计算完成
                setTimeout(() => {
                    document.getElementById('calculation-progress').classList.add('hidden');
                    displayAllResults();
                }, 500);
                return;
            }
            
            const methodId = selectedMethods[index];
            const progressItem = document.getElementById(`progress-${methodId}`);
            
            // 更新进度状态
            progressItem.className = 'progress-item running';
            progressItem.innerHTML = `
                <span class="loading"></span>
                <span>${getMethodName(methodId)} - 计算中...</span>
            `;
            
            // 模拟计算延迟
            setTimeout(() => {
                // 根据方法ID计算结果
                let result = {};
                
                switch(methodId) {
                    case 1:
                        result = calculateMethod1();
                        break;
                    case 2:
                        result = calculateMethod2();
                        break;
                    case 3:
                        result = calculateMethod3();
                        break;
                    case 4:
                        result = calculateMethod4();
                        break;
                    case 5:
                        result = calculateMethod5();
                        break;
                }
                
                // 保存计算结果
                calculationResults[methodId] = {
                    methodName: getMethodName(methodId),
                    result: result
                };
                
                // 更新进度状态
                progressItem.className = 'progress-item completed';
                progressItem.innerHTML = `
                    <i class="fas fa-check-circle"></i>
                    <span>${getMethodName(methodId)} - 计算完成</span>
                `;
                
                // 继续计算下一个方法
                calculateMethodsSequentially(index + 1);
            }, 800);
        }
        
        // 获取方法名称
        function getMethodName(methodId) {
            const methodNames = {
                1: '方法一：架空输电线路螺旋锚基础设计规范',
                2: '方法二：架空输电线路基础设计规程',
                3: '方法三：太阳能发电站支架基础技术规范',
                4: '方法四：Chance Technical Design Manual',
                5: '方法五：IPENZ Practice Note 28'
            };
            return methodNames[methodId] || `方法${methodId}`;
        }
        
        // 显示所有结果
        function displayAllResults() {
            const resultsContainer = document.getElementById('all-results');
            
            if (Object.keys(calculationResults).length === 0) {
                resultsContainer.innerHTML = '<p style="text-align: center; color: #777;">没有计算结果，请先进行计算。</p>';
                return;
            }
            
            let html = '<h3 style="color: #2c3e50; margin-bottom: 20px;">五种方法计算结果对比</h3>';
            
            // 为每个方法创建结果卡片
            selectedMethods.forEach(methodId => {
                if (calculationResults[methodId]) {
                    const { methodName, result } = calculationResults[methodId];
                    
                    html += `
                        <div class="method-result-card">
                            <div class="method-result-header">
                                <div class="method-result-title">${methodName}</div>
                                <div style="font-size: 14px; color: #666;">计算完成</div>
                            </div>
                            <div class="results-grid">
                                <div class="result-item">
                                    <h4>极限抗拉承载力</h4>
                                    <div class="result-value">${result.tension}<span class="result-unit">kN</span></div>
                                    ${result.tension_details ? `<div class="result-details">${result.tension_details}</div>` : ''}
                                </div>
                                <div class="result-item">
                                    <h4>极限抗压承载力</h4>
                                    <div class="result-value">${result.compression}<span class="result-unit">kN</span></div>
                                    ${result.compression_details ? `<div class="result-details">${result.compression_details}</div>` : ''}
                                </div>
                            </div>
                            ${result.details ? `<div style="margin-top: 15px; padding: 10px; background-color: #f8fafc; border-radius: 6px; font-size: 14px; color: #666;">${result.details}</div>` : ''}
                        </div>
                    `;
                }
            });
            
            // 添加总结
            html += `
                <div class="method-result-card" style="background-color: #f0f7ff;">
                    <div class="method-result-header">
                        <div class="method-result-title">计算结果总结</div>
                    </div>
                    <p style="color: #555; margin-bottom: 15px;">
                        以上为${selectedMethods.length}种计算方法的对比结果。不同计算方法基于不同的假设和规范，计算结果可能有所不同。
                        实际工程应用中应根据具体规范要求选择合适的方法，并考虑安全系数。
                    </p>
                    <p style="color: #555; font-size: 14px;">
                        计算时间: ${new Date().toLocaleString()}<br>
                        参数摘要: ${pileParams.n}个叶片，总埋深${pileParams.L}m，${soilLayers.length}个土层
                    </p>
                </div>
            `;
            
            resultsContainer.innerHTML = html;
        }
        
        // ====================== 方法一：架空输电线路螺旋锚基础设计规范 ======================
        function calculateMethod1() {
            const { n, Ds, Sh, L, Hh_bot, phi_pile_deg, Dh } = pileParams;
            
            // 检查Dh数组长度是否与叶片数量n一致
            if (Dh.length !== n) {
                return {
                    tension: "参数错误",
                    compression: "参数错误",
                    tension_details: "叶片直径数组长度必须等于叶片数量",
                    compression_details: "叶片直径数组长度必须等于叶片数量",
                    details: "计算失败：叶片直径数组长度必须等于叶片数量"
                };
            }
            
            // 计算叶片埋深（从地面起算）
            const Hh = new Array(n);
            for (let idx = 0; idx < n; idx++) {
                Hh[idx] = L - (n - idx - 1) * Sh - Hh_bot;  // 从上到下
            }
            
            // 确定每个叶片所在的土层
            const layer_idx = new Array(n).fill(0);
            for (let i = 0; i < n; i++) {
                let found = false;
                for (let j = 0; j < soilLayers.length; j++) {
                    if (Hh[i] >= soilLayers[j].depth_top && Hh[i] <= soilLayers[j].depth_bottom) {
                        layer_idx[i] = j;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return {
                        tension: "参数错误",
                        compression: "参数错误",
                        tension_details: `叶片${i+1}深度${Hh[i].toFixed(2)}m不在任何土层范围内`,
                        compression_details: `叶片${i+1}深度${Hh[i].toFixed(2)}m不在任何土层范围内`,
                        details: "计算失败：叶片深度超出土层范围"
                    };
                }
            }
            
            // 将桩的倾斜角转换为弧度
            const phi_pile_rad = phi_pile_deg * Math.PI / 180;
            
            // 计算抗拉承载力
            const Qt = OverheadModel_Tensile();
            
            // 计算抗压承载力
            const Qc = OverheadModel_compression();
            
            return {
                tension: Qt.toFixed(2),
                compression: Qc.toFixed(2),
                tension_details: `基于${n}个叶片计算`,
                compression_details: `基于${n}个叶片计算`,
                details: `叶片数量: ${n}, 总埋深: ${L}m, 土层数量: ${soilLayers.length}`
            };
            
            // 抗拉承载力计算函数
            function OverheadModel_Tensile() {
                // 初始化变量
                const Qj = new Array(n).fill(0);  // 存储每个叶片的承载力
                const Hij = new Array(n).fill(0); // 存储每个叶片的Hij值
                
                // 计算每个叶片的Hij（公式5）
                for (let j = 0; j < n; j++) {
                    if (j === 0) {
                        if (Hh[0] <= soilLayers[layer_idx[0]].lambda * Dh[0]) {
                            Hij[0] = 0;
                        } else {
                            Hij[0] = Hh[0] - soilLayers[layer_idx[0]].lambda * Dh[0];
                        }
                    } else {
                        if (Hh[j] - Hh[j-1] <= soilLayers[layer_idx[j]].lambda * Dh[j]) {
                            Hij[j] = Hh[j-1];
                        } else {
                            Hij[j] = Hh[j] - soilLayers[layer_idx[j]].lambda * Dh[j];
                        }
                    }
                }
                
                // 计算每个叶片的承载力Qj（公式2）
                for (let j = 0; j < n; j++) {
                    const layer = soilLayers[layer_idx[j]];
                    const term1 = (Dh[j] * Hh[j] * Math.cos(phi_pile_rad) / 4) * layer.gamma;
                    const term2 = (layer.psi * (Hh[j] * Hh[j] - Hij[j] * Hij[j]) / 2) * layer.gamma;
                    const term3 = (Hh[j] - Hij[j]) * layer.c;
                    
                    Qj[j] = Math.PI * Dh[j] * (term1 + term2 + term3);
                }
                
                // 计算无效长度L0（公式4）
                let L0_sum = 0;
                for (let j = 0; j < n; j++) {
                    L0_sum += soilLayers[layer_idx[j]].lambda * Dh[j];
                }
                const L0 = 0.5 * L0_sum + 1.5;
                
                // 计算桩杆侧摩阻力Qsh（公式3）
                let Qsh = 0;
                for (let layer = 0; layer < soilLayers.length; layer++) {
                    // 计算该土层内的桩杆长度
                    const layer_top = soilLayers[layer].depth_top;
                    const layer_bottom = soilLayers[layer].depth_bottom;
                    
                    // 桩杆在该土层内的有效长度（扣除无效长度部分）
                    let layer_length = 0;
                    if (L - L0 < layer_top) {
                        // 有效桩段完全在该土层下方
                        continue;
                    } else if (L - L0 >= layer_bottom) {
                        // 有效桩段完全包含该土层
                        layer_length = layer_bottom - Math.max(layer_top, 0);
                    } else {
                        // 有效桩段部分在该土层内
                        layer_length = Math.max(0, (L - L0) - layer_top);
                    }
                    
                    if (layer_length > 0) {
                        Qsh += Math.PI * Ds * layer_length * soilLayers[layer].qs_t;
                    }
                }
                
                // 计算总极限承载力（公式1）
                let Qt_sum = 0;
                for (let j = 0; j < n; j++) {
                    Qt_sum += Qj[j];
                }
                return Qt_sum + Qsh;
            }
            
            // 抗压承载力计算函数
            function OverheadModel_compression() {
                // 计算L0（上部剧烈扰动深度和近叶片附近随叶片移动的土体厚度之和）
                let L0_sum = 0;
                for (let j = 0; j < n; j++) {
                    L0_sum += soilLayers[layer_idx[j]].lambda * Dh[j];
                }
                const L0 = 0.5 * L0_sum;
                
                // 初始化抗压承载力
                let Qc = 0;
                
                // 1. 计算非最底部叶片部分（j=1到n-1）
                for (let j = 0; j < n-1; j++) {
                    // 计算Hcj（第j个叶片下部剪切体顶面埋深）
                    let Hcj;
                    if (Hh[j+1] - Hh[j] <= soilLayers[layer_idx[j]].lambda * Dh[j]) {
                        Hcj = Hh[j+1];
                    } else {
                        Hcj = Hh[j] + soilLayers[layer_idx[j]].lambda * Dh[j];
                    }
                    
                    // 计算Qc_j
                    const layer = soilLayers[layer_idx[j]];
                    const Qc_j = Math.PI * Dh[j] * ((layer.psi * (Hcj * Hcj - Hh[j] * Hh[j]) * layer.gamma) / 2 +
                                 (Hcj - Hh[j]) * layer.c);
                    Qc += Qc_j;
                }
                
                // 2. 计算最底部叶片部分（Qc_n）
                // 使用最底部叶片所在土层的qp和最底部叶片的直径
                const bottom_layer = soilLayers[layer_idx[n-1]];
                const Qc_n = (Math.PI * Dh[n-1] * Dh[n-1] * bottom_layer.qp) / 4;
                Qc += Qc_n;
                
                // 3. 计算桩杆抗压时的侧摩阻力部分（分段计算）
                let Qsh_c = 0;
                for (let layer = 0; layer < soilLayers.length; layer++) {
                    // 计算该土层内的桩杆长度
                    const layer_top = soilLayers[layer].depth_top;
                    const layer_bottom = soilLayers[layer].depth_bottom;
                    
                    // 桩杆在该土层内的有效长度（扣除无效长度部分）
                    let layer_length = 0;
                    if (L - L0 < layer_top) {
                        // 有效桩段完全在该土层下方
                        continue;
                    } else if (L - L0 >= layer_bottom) {
                        // 有效桩段完全包含该土层
                        layer_length = layer_bottom - Math.max(layer_top, 0);
                    } else {
                        // 有效桩段部分在该土层内
                        layer_length = Math.max(0, (L - L0) - layer_top);
                    }
                    
                    if (layer_length > 0) {
                        Qsh_c += Math.PI * Ds * layer_length * soilLayers[layer].qs_c;
                    }
                }
                
                Qc += Qsh_c;
                return Qc;
            }
        }
        
        // ====================== 方法二：架空输电线路基础设计规程 ======================
        function calculateMethod2() {
            const { n, Ds, Sh, L, Hh_bot, Dh } = pileParams;
            
            // 检查Dh数组长度
            if (Dh.length !== n) {
                return {
                    tension: "参数错误",
                    compression: "参数错误",
                    tension_details: "叶片直径数组长度必须等于叶片数量",
                    compression_details: "叶片直径数组长度必须等于叶片数量",
                    details: "计算失败：叶片直径数组长度必须等于叶片数量"
                };
            }
            
            // 计算叶片位置
            const Hh = new Array(n);
            for (let idx = 0; idx < n; idx++) {
                Hh[idx] = L - (n - idx - 1) * Sh - Hh_bot; // 从上到下
            }
            const Hh1 = Hh[0];
            
            // 判断顶部锚盘所在土层
            let top_layer_idx = -1;
            for (let i = 0; i < soilLayers.length; i++) {
                if (Hh1 >= soilLayers[i].depth_top && Hh1 <= soilLayers[i].depth_bottom) {
                    top_layer_idx = i;
                    break;
                }
            }
            
            if (top_layer_idx === -1) {
                return {
                    tension: "参数错误",
                    compression: "参数错误",
                    tension_details: `顶部锚盘深度${Hh1.toFixed(2)}m不在任何土层范围内`,
                    compression_details: `顶部锚盘深度${Hh1.toFixed(2)}m不在任何土层范围内`,
                    details: "计算失败：顶部锚盘深度超出土层范围"
                };
            }
            
            // 判断埋深模式
            const is_shallow = Hh1 / Dh[0] < 5;
            
            // 计算锚盘面积
            const A = new Array(n);
            for (let i = 0; i < n; i++) {
                A[i] = Math.PI * (Dh[i]/2) * (Dh[i]/2) - Math.PI * (Ds/2) * (Ds/2);
            }
            
            // 使用顶部锚盘所在土层的参数计算
            const phi_top = soilLayers[top_layer_idx].phi;
            
            // 计算顶部锚盘的参数
            const beta = phi_top / 2;  // 破坏面与铅垂面夹角
            const beta_rad = beta * Math.PI / 180;
            const phi_rad = phi_top * Math.PI / 180;
            
            // 计算侧压力系数 Ku
            const Ku_top = calculate_Ku_interp(phi_top, Hh1, Dh[0]);
            
            // 计算顶部锚盘上拔承载力参数 Nqu
            const Nqu_top = calculate_Nqu_interp(phi_top, Hh1, Dh[0]);
            
            // 计算黏性土锚盘上拔承载力参数 Ncu
            const Ncu_top = calculate_Ncu(Hh1, Dh[0]);
            
            // 计算极限抗拔承载力
            let Qu, Qs, Qf;
            
            if (is_shallow) {
                // 浅埋锚顶部锚盘上拔承载力（使用顶部土层参数）
                const top_layer = soilLayers[top_layer_idx];
                Qu = calculate_shallow_Qu1(top_layer.gamma, phi_rad, top_layer.c, Hh1, Dh[0], beta_rad, Ku_top);
                Qs = 0;  // 浅埋锚时锚杆摩阻力为0
            } else {
                // 深埋锚顶部锚盘上拔承载力（使用顶部土层参数）
                const top_layer = soilLayers[top_layer_idx];
                Qu = top_layer.gamma * Hh1 * A[0] * Nqu_top + A[0] * top_layer.c * Ncu_top;
                
                // 锚杆上的摩阻力（分段计算）
                Qs = calculate_Qs_multilayer(Ds, Hh1);
            }
            
            // 顶、底锚盘间土层摩擦力（分段计算）
            const Dh_mean = Dh.reduce((sum, val) => sum + val, 0) / Dh.length;
            Qf = calculate_Qf_multilayer(Dh_mean, Hh1, L);
            
            // 总抗拔承载力
            const Qu_total = Qu + Qf + Qs;
            
            // 判断底部锚盘所在土层
            let bottom_layer_idx = -1;
            for (let i = 0; i < soilLayers.length; i++) {
                if (L >= soilLayers[i].depth_top && L <= soilLayers[i].depth_bottom) {
                    bottom_layer_idx = i;
                    break;
                }
            }
            
            if (bottom_layer_idx === -1) {
                return {
                    tension: "参数错误",
                    compression: "参数错误",
                    tension_details: `底部锚盘深度${L.toFixed(2)}m不在任何土层范围内`,
                    compression_details: `底部锚盘深度${L.toFixed(2)}m不在任何土层范围内`,
                    details: "计算失败：底部锚盘深度超出土层范围"
                };
            }
            
            // 使用底部锚盘所在土层的参数计算Nqu
            const phi_bottom = soilLayers[bottom_layer_idx].phi;
            const Nqu_bottom = calculate_Nqu_interp(phi_bottom, L, Dh[n-1]);
            
            // 底部锚盘下压承载力
            const bottom_layer = soilLayers[bottom_layer_idx];
            const Qp = bottom_layer.gamma * L * A[n-1] * Nqu_bottom + A[n-1] * bottom_layer.c * Ncu_top;
            
            // 总抗压承载力（使用相同的Qf和Qs）
            const Qc_total = Qp + Qf + Qs;
            
            return {
                tension: Qu_total.toFixed(2),
                compression: Qc_total.toFixed(2),
                tension_details: is_shallow ? "浅埋锚模式" : "深埋锚模式",
                compression_details: `底部锚盘直径: ${Dh[n-1].toFixed(3)}m`,
                details: `模式: ${is_shallow ? "浅埋" : "深埋"}, 顶部叶片深度: ${Hh1.toFixed(2)}m, 底部叶片深度: ${L.toFixed(2)}m`
            };
            
            // 辅助函数
            function calculate_Ku_interp(phi, Hh1, Dh) {
                const ratio = Hh1 / Dh;
                
                // 已知点的内摩擦角值
                const phi_known = [25, 34, 45, 47];
                
                // 检查是否需要插值
                if (phi_known.includes(phi)) {
                    return calculate_Ku_at_known_phi(phi, ratio);
                } else {
                    // 使用插值法计算
                    // 找到phi所在的区间
                    if (phi < Math.min(...phi_known)) {
                        // 小于最小值，使用最小值的公式
                        return calculate_Ku_at_known_phi(Math.min(...phi_known), ratio);
                    } else if (phi > Math.max(...phi_known)) {
                        // 大于最大值，使用最大值的公式
                        return calculate_Ku_at_known_phi(Math.max(...phi_known), ratio);
                    } else {
                        // 在已知点之间，找到相邻的两个点
                        let idx = 0;
                        for (let i = 0; i < phi_known.length; i++) {
                            if (phi_known[i] < phi) {
                                idx = i;
                            }
                        }
                        const phi_low = phi_known[idx];
                        const phi_high = phi_known[idx+1];
                        
                        // 计算两个相邻点的Ku值
                        const Ku_low = calculate_Ku_at_known_phi(phi_low, ratio);
                        const Ku_high = calculate_Ku_at_known_phi(phi_high, ratio);
                        
                        // 线性插值
                        return Ku_low + (Ku_high - Ku_low) * (phi - phi_low) / (phi_high - phi_low);
                    }
                }
            }
            
            function calculate_Ku_at_known_phi(phi, ratio) {
                // 在已知内摩擦角点计算Ku值
                switch (phi) {
                    case 25:
                        return 0.5;
                    case 34:
                        if (ratio <= 6) {
                            return 0.5 + 0.1 * ratio;
                        } else {
                            return 1.1;
                        }
                    case 45:
                        if (ratio <= 9) {
                            return 0.5 + 0.3 * ratio;
                        } else {
                            return 3.2;
                        }
                    case 47:
                        if (ratio <= 10) {
                            return 0.5 + 0.34 * ratio;
                        } else {
                            return 3.9;
                        }
                    default:
                        return 0.5;
                }
            }
            
            function calculate_Nqu_interp(phi, Hh1, Dh) {
                const ratio = Hh1 / Dh;
                
                // 已知点的内摩擦角值
                const phi_known = [25, 35, 45];
                
                // 检查是否需要插值
                if (phi_known.includes(phi)) {
                    return calculate_Nqu_at_known_phi(phi, ratio);
                } else {
                    // 使用插值法计算
                    // 找到phi所在的区间
                    if (phi < Math.min(...phi_known)) {
                        // 小于最小值，使用最小值的公式
                        return calculate_Nqu_at_known_phi(Math.min(...phi_known), ratio);
                    } else if (phi > Math.max(...phi_known)) {
                        // 大于最大值，使用最大值的公式
                        return calculate_Nqu_at_known_phi(Math.max(...phi_known), ratio);
                    } else {
                        // 在已知点之间，找到相邻的两个点
                        let idx = 0;
                        for (let i = 0; i < phi_known.length; i++) {
                            if (phi_known[i] < phi) {
                                idx = i;
                            }
                        }
                        const phi_low = phi_known[idx];
                        const phi_high = phi_known[idx+1];
                        
                        // 计算两个相邻点的Nqu值
                        const Nqu_low = calculate_Nqu_at_known_phi(phi_low, ratio);
                        const Nqu_high = calculate_Nqu_at_known_phi(phi_high, ratio);
                        
                        // 线性插值
                        return Nqu_low + (Nqu_high - Nqu_low) * (phi - phi_low) / (phi_high - phi_low);
                    }
                }
            }
            
            function calculate_Nqu_at_known_phi(phi, ratio) {
                // 在已知内摩擦角点计算Nqu值
                if (phi < 25) {
                    return 5;
                } else if (phi == 25) {
                    if (ratio <= 9) {
                        return 2.66 * ratio - 0.074 * ratio * ratio;
                    } else {
                        return 18;
                    }
                } else if (phi == 35) {
                    if (ratio <= 9) {
                        return 3.138 * ratio + 0.703 * ratio * ratio - 0.062 * ratio * ratio * ratio;
                    } else {
                        return 40;
                    }
                } else if (phi == 45) {
                    if (ratio <= 9) {
                        return 4.266 * ratio + 3.018 * ratio * ratio - 0.251 * ratio * ratio * ratio;
                    } else {
                        return 100;
                    }
                } else {
                    return 5;
                }
            }
            
            function calculate_Ncu(Hh1, Dh) {
                const ratio = Hh1 / Dh;
                
                if (ratio < 4) {
                    return -0.7 * ratio * ratio + 5.3 * ratio;
                } else {
                    return 9.6;
                }
            }
            
            function calculate_shallow_Qu1(gamma, phi_rad, c, Hh1, Dh, beta_rad, Ku) {
                // 第一项
                const term1 = Math.PI * gamma * (Hh1 * Hh1 * Hh1 * Math.tan(beta_rad)/3 + Dh * Hh1 * Hh1 * Math.tan(beta_rad)/2 + Dh * Dh * Hh1/4);
                
                // 第二项和第三项的公共部分
                const common_factor1 = (1 + Ku)/2 - (1 - Ku)/2 * Math.cos(2 * beta_rad);
                const common_factor2 = (Dh * Hh1 * Hh1)/4 + (Hh1 * Hh1 * Hh1 * Math.tan(beta_rad))/6;
                
                const term2 = 2 * Math.PI * gamma * Math.tan(phi_rad) * common_factor1 * common_factor2;
                const term3 = -2 * Math.PI * gamma * Math.tan(beta_rad) * common_factor1 * common_factor2;
                
                // 第四项和第五项的公共部分
                const common_factor3 = (Dh * Hh1)/2 + (Hh1 * Hh1 * Math.tan(beta_rad))/2;
                
                const term4 = 2 * c * Math.PI * common_factor3;
                const term5 = -2 * c * Math.PI * Math.tan(beta_rad) * common_factor3;
                
                // 总和
                return term1 + term2 + term3 + term4 + term5;
            }
            
            function calculate_Qs_multilayer(Ds, Hh1) {
                let Qs = 0;
                
                for (let layer = 0; layer < soilLayers.length; layer++) {
                    // 计算该土层在锚杆范围内的深度
                    const layer_top = Math.max(soilLayers[layer].depth_top, 0);  // 锚杆从地面开始
                    const layer_bottom = Math.min(soilLayers[layer].depth_bottom, Hh1);
                    
                    // 如果该土层与锚杆有重叠
                    if (layer_bottom > layer_top) {
                        const layer_thickness = layer_bottom - layer_top;
                        
                        // 计算该土层中点深度
                        const z_mid = (layer_top + layer_bottom) / 2;
                        
                        // 计算该土层的Ku值
                        const Ku_layer = calculate_Ku_interp(soilLayers[layer].phi, z_mid, 0);
                        
                        // 计算该土层的侧摩阻力贡献
                        const phi_rad_layer = soilLayers[layer].phi * Math.PI / 180;
                        const term1 = Math.PI * Ds * layer_thickness * (soilLayers[layer].gamma * z_mid / 2) *
                                    Ku_layer * Math.tan(phi_rad_layer);
                        const term2 = Math.PI * soilLayers[layer].c * Ds * layer_thickness;
                        
                        Qs += term1 + term2;
                    }
                }
                
                return Qs;
            }
            
            function calculate_Qf_multilayer(Dh, Hh1, L) {
                let Qf = 0;
                
                for (let layer = 0; layer < soilLayers.length; layer++) {
                    // 计算该土层在Hh1到L范围内的深度
                    const layer_top = Math.max(soilLayers[layer].depth_top, Hh1);
                    const layer_bottom = Math.min(soilLayers[layer].depth_bottom, L);
                    
                    // 如果该土层在计算范围内
                    if (layer_bottom > layer_top) {
                        const layer_thickness = layer_bottom - layer_top;
                        
                        // 计算该土层中点深度
                        const z_mid = (layer_top + layer_bottom) / 2;
                        
                        // 计算该土层的Ku值
                        const Ku_layer = calculate_Ku_interp(soilLayers[layer].phi, z_mid, 0);
                        
                        // 计算该土层的摩擦力贡献
                        const phi_rad_layer = soilLayers[layer].phi * Math.PI / 180;
                        
                        // 使用中点深度计算贡献
                        const term1 = (Math.PI/2) * Dh * soilLayers[layer].gamma * layer_thickness *
                                    (2 * z_mid) * Ku_layer * Math.tan(phi_rad_layer);
                        const term2 = Math.PI * soilLayers[layer].c * Dh * layer_thickness;
                        
                        Qf += term1 + term2;
                    }
                }
                
                return Qf;
            }
        }
        
        // ====================== 方法三：太阳能发电站支架基础技术规范 ======================
        function calculateMethod3() {
            const { n, Ds, Sh, L, Hh_bot, Dh } = pileParams;
            
            // 检查Dh数组长度是否与叶片数量n一致
            if (Dh.length !== n) {
                return {
                    tension: "参数错误",
                    compression: "参数错误",
                    tension_details: "叶片直径数组长度必须等于叶片数量",
                    compression_details: "叶片直径数组长度必须等于叶片数量",
                    details: "计算失败：叶片直径数组长度必须等于叶片数量"
                };
            }
            
            // 计算叶片位置
            const depths_blades = new Array(n);
            for (let idx = 0; idx < n; idx++) {
                depths_blades[idx] = L - (n - idx - 1) * Sh - Hh_bot; // 从上到下
            }
            
            // 构建土层参数矩阵
            const soil_layers_tension = [];
            const soil_layers_compression = [];
            
            for (let i = 0; i < soilLayers.length; i++) {
                // 确定土质类型代码
                let soil_type_code;
                switch(soilLayers[i].soil_type) {
                    case 'rock': soil_type_code = 1; break;
                    case 'sand': soil_type_code = 2; break;
                    case 'clay': soil_type_code = 3; break;
                    case 'silt': soil_type_code = 4; break;
                    default: soil_type_code = 3; // 默认黏性土
                }
                
                soil_layers_tension.push([
                    soilLayers[i].depth_top,
                    soilLayers[i].depth_bottom,
                    soil_type_code,
                    soilLayers[i].qs_t
                ]);
                
                soil_layers_compression.push([
                    soilLayers[i].depth_top,
                    soilLayers[i].depth_bottom,
                    soil_type_code,
                    soilLayers[i].qs_c,
                    soilLayers[i].qp
                ]);
            }
            
            // 计算抗拔承载力
            const T_uk = SolarMoael('tension', depths_blades, soil_layers_tension);
            
            // 计算抗压承载力
            const Q_uk = SolarMoael('compression', depths_blades, soil_layers_compression);
            
            return {
                tension: T_uk.toFixed(2),
                compression: Q_uk.toFixed(2),
                tension_details: "采用离散积分法计算侧阻力",
                compression_details: "考虑桩端阻力",
                details: `离散积分步长: 0.01m, 叶片数量: ${n}`
            };
            
            // 太阳能规范计算方法
            function SolarMoael(mode, depths_blades, soil_layers) {
                // 离散步长
                const dz = 0.01;
                
                // 排序叶片位置和对应的直径
                const sorted_indices = depths_blades.map((val, idx) => idx).sort((a, b) => depths_blades[a] - depths_blades[b]);
                const sorted_depths = sorted_indices.map(idx => depths_blades[idx]);
                const sorted_Dh = sorted_indices.map(idx => Dh[idx]);
                
                // 离散桩长
                const z_points = [];
                for (let z = 0; z <= L; z += dz) {
                    z_points.push(z);
                }
                
                // 初始化数组
                const u_i = new Array(z_points.length).fill(0);
                const qsik = new Array(z_points.length).fill(0);
                const lambda = new Array(z_points.length).fill(1);  // 抗压时lambda=1
                
                // 计算每个深度点的u_i
                for (let i = 0; i < z_points.length; i++) {
                    const zi = z_points[i];
                    if (mode === 'compression') {
                        u_i[i] = compute_ui_compression(zi, sorted_Dh, sorted_depths);
                    } else {  // tension
                        u_i[i] = compute_ui_tension(zi, sorted_Dh, sorted_depths);
                    }
                }
                
                // 分配qsik和lambda
                for (let i = 0; i < z_points.length; i++) {
                    const zi = z_points[i];
                    // 找到土层索引
                    let layer_idx = -1;
                    for (let j = 0; j < soil_layers.length; j++) {
                        if (zi >= soil_layers[j][0] && zi < soil_layers[j][1]) {
                            layer_idx = j;
                            break;
                        }
                    }
                    
                    if (layer_idx === -1) {
                        if (zi === L && zi === soil_layers[soil_layers.length-1][1]) {
                            layer_idx = soil_layers.length - 1;
                        } else {
                            // 使用最后一个土层
                            layer_idx = soil_layers.length - 1;
                        }
                    }
                    
                    qsik[i] = soil_layers[layer_idx][3];
                    if (mode === 'tension') {
                        const soil_type = soil_layers[layer_idx][2];
                        lambda[i] = get_lambda(soil_type);
                    }
                }
                
                // 计算侧阻力
                let side_resistance = 0;
                for (let i = 0; i < z_points.length - 1; i++) {
                    const z_diff = z_points[i+1] - z_points[i];
                    if (mode === 'compression') {
                        side_resistance += u_i[i] * qsik[i] * z_diff;
                    } else {
                        side_resistance += lambda[i] * u_i[i] * qsik[i] * z_diff;
                    }
                }
                
                // 计算总承载力
                if (mode === 'compression') {
                    // 找到桩端所在土层
                    let layer_idx_end = -1;
                    for (let j = 0; j < soil_layers.length; j++) {
                        if (L >= soil_layers[j][0] && L < soil_layers[j][1]) {
                            layer_idx_end = j;
                            break;
                        }
                    }
                    if (layer_idx_end === -1) {
                        layer_idx_end = soil_layers.length - 1;
                    }
                    
                    const qpk = soil_layers[layer_idx_end][4];  // 桩端阻力标准值
                    // 使用最下面一个叶片的直径计算投影面积
                    const A_D = Math.PI * (Dh[n-1]/2) * (Dh[n-1]/2) - Math.PI * (Ds/2) * (Ds/2);
                    const end_resistance = qpk * A_D;
                    return side_resistance + end_resistance;
                } else {
                    return side_resistance;
                }
            }
            
            // 辅助函数：获取抗拔系数
            function get_lambda(soil_type) {
                switch (soil_type) {
                    case 1:  // 岩石
                        return 0.8;
                    case 2:  // 砂土
                        return 0.5;
                    case 3:  // 黏性土
                    case 4:  // 粉土
                        return 0.7;
                    default:
                        return 0.7;
                }
            }
            
            // 辅助函数：抗压计算u_i
            function compute_ui_compression(z, Dh, depths_blades) {
                // 如果没有叶片
                if (depths_blades.length === 0) {
                    return Math.PI * Ds;
                }
                
                // 只有一个叶片的情况
                if (depths_blades.length === 1) {
                    const z_first = depths_blades[0];
                    const D_first = Dh[0];
                    
                    // 最上一道叶片以上
                    if (z < z_first) {
                        if (z >= z_first - D_first) {  // 叶片以上1D范围
                            return 0;
                        } else {
                            return Math.PI * Ds;
                        }
                    // 最下一道叶片以下
                    } else if (z > z_first) {
                        return Math.PI * Ds;
                    } else {
                        // 叶片位置本身，保守取0
                        return 0;
                    }
                }
                
                // 多个叶片的情况
                const z_first = depths_blades[0];
                const D_first = Dh[0];
                const z_last = depths_blades[depths_blades.length - 1];
                const D_last = Dh[depths_blades.length - 1];
                
                // 最上一道叶片以上
                if (z < z_first) {
                    if (z >= z_first - D_first) {  // 叶片以上1D范围
                        return 0;
                    } else {
                        return Math.PI * Ds;
                    }
                }
                
                // 最下一道叶片以下
                if (z > z_last) {
                    return Math.PI * Ds;
                }
                
                // 叶片之间（多个叶片）
                // 找到上叶片和下叶片
                let idx_low = -1;
                for (let i = 0; i < depths_blades.length; i++) {
                    if (depths_blades[i] > z) {
                        idx_low = i;
                        break;
                    }
                }
                
                if (idx_low === -1) {  // z等于最后一个叶片
                    idx_low = depths_blades.length - 1;
                    const z_low = depths_blades[idx_low];
                    const D_low = Dh[idx_low];
                    const idx_up = idx_low - 1;
                    const z_up = depths_blades[idx_up];
                    const D_up = Dh[idx_up];
                    
                    // 计算等效直径（取两个叶片直径的较大值）
                    const D_eff = Math.max(D_up, D_low);
                    const hp = z_low - z_up;
                    
                    if (hp <= 3 * D_eff) {
                        return Math.PI * D_eff;
                    } else if (hp < 4 * D_eff) {  // 3D < hp < 4D
                        if (z >= z_low - (hp - 3 * D_eff)) {
                            return 0;
                        } else {
                            return Math.PI * D_eff;
                        }
                    } else {  // hp >= 4D
                        if (z <= z_up + 3 * D_eff) {
                            return Math.PI * D_eff;
                        } else if (z >= z_low - D_eff) {
                            return 0;
                        } else {
                            return Math.PI * Ds;
                        }
                    }
                } else {
                    const z_low = depths_blades[idx_low];
                    const D_low = Dh[idx_low];
                    if (idx_low === 0) {
                        // 不会发生，因为z>=z_first
                        return Math.PI * Ds;
                    } else {
                        const idx_up = idx_low - 1;
                        const z_up = depths_blades[idx_up];
                        const D_up = Dh[idx_up];
                        
                        // 计算等效直径（取两个叶片直径的较大值）
                        const D_eff = Math.max(D_up, D_low);
                        const hp = z_low - z_up;
                        
                        if (hp <= 3 * D_eff) {
                            return Math.PI * D_eff;
                        } else if (hp < 4 * D_eff) {  // 3D < hp < 4D
                            if (z >= z_low - (hp - 3 * D_eff)) {
                                return 0;
                            } else {
                                return Math.PI * D_eff;
                            }
                        } else {  // hp >= 4D
                            if (z <= z_up + 3 * D_eff) {
                                return Math.PI * D_eff;
                            } else if (z >= z_low - D_eff) {
                                return 0;
                            } else {
                                return Math.PI * Ds;
                            }
                        }
                    }
                }
            }
            
            // 辅助函数：抗拔计算u_i
            function compute_ui_tension(z, Dh, depths_blades) {
                // 如果没有叶片
                if (depths_blades.length === 0) {
                    return Math.PI * Ds;
                }
                
                // 只有一个叶片的情况
                if (depths_blades.length === 1) {
                    const z_first = depths_blades[0];
                    const D_first = Dh[0];
                    
                    // 最上一道叶片以上
                    if (z < z_first) {
                        if (z >= z_first - 2 * D_first) {  // 叶片以上2D范围
                            return Math.PI * D_first;
                        } else {
                            return Math.PI * Ds;
                        }
                    // 最下一道叶片以下
                    } else if (z > z_first) {
                        return Math.PI * Ds;
                    } else {
                        // 叶片位置本身，保守取0
                        return 0;
                    }
                }
                
                // 多个叶片的情况
                const z_first = depths_blades[0];
                const D_first = Dh[0];
                const z_last = depths_blades[depths_blades.length - 1];
                const D_last = Dh[depths_blades.length - 1];
                
                // 最上一道叶片以上
                if (z < z_first) {
                    if (z >= z_first - 2 * D_first) {  // 叶片以上2D范围
                        return Math.PI * D_first;
                    } else {
                        return Math.PI * Ds;
                    }
                }
                
                // 最下一道叶片以下
                if (z > z_last) {
                    return Math.PI * Ds;
                }
                
                // 叶片之间（多个叶片）
                let idx_low = -1;
                for (let i = 0; i < depths_blades.length; i++) {
                    if (depths_blades[i] > z) {
                        idx_low = i;
                        break;
                    }
                }
                
                if (idx_low === -1) {
                    idx_low = depths_blades.length - 1;
                    const z_low = depths_blades[idx_low];
                    const D_low = Dh[idx_low];
                    const idx_up = idx_low - 1;
                    const z_up = depths_blades[idx_up];
                    const D_up = Dh[idx_up];
                    
                    // 计算等效直径（取两个叶片直径的较大值）
                    const D_eff = Math.max(D_up, D_low);
                    const hp = z_low - z_up;
                    
                    if (hp <= 3 * D_eff) {
                        return Math.PI * D_eff;
                    } else if (hp < 4 * D_eff) {  // 3D < hp < 4D
                        if (z <= z_up + (hp - 3 * D_eff)) {
                            return 0;
                        } else {
                            return Math.PI * D_eff;
                        }
                    } else {  // hp >= 4D
                        if (z >= z_low - 3 * D_eff) {
                            return Math.PI * D_eff;
                        } else if (z <= z_up + D_eff) {
                            return 0;
                        } else {
                            return Math.PI * Ds;
                        }
                    }
                } else {
                    const z_low = depths_blades[idx_low];
                    const D_low = Dh[idx_low];
                    if (idx_low === 0) {
                        // 不会发生，因为z>=z_first
                        return Math.PI * Ds;
                    } else {
                        const idx_up = idx_low - 1;
                        const z_up = depths_blades[idx_up];
                        const D_up = Dh[idx_up];
                        
                        // 计算等效直径（取两个叶片直径的较大值）
                        const D_eff = Math.max(D_up, D_low);
                        const hp = z_low - z_up;
                        
                        if (hp <= 3 * D_eff) {
                            return Math.PI * D_eff;
                        } else if (hp < 4 * D_eff) {  // 3D < hp < 4D
                            if (z <= z_up + (hp - 3 * D_eff)) {
                                return 0;
                            } else {
                                return Math.PI * D_eff;
                            }
                        } else {  // hp >= 4D
                            if (z >= z_low - 3 * D_eff) {
                                return Math.PI * D_eff;
                            } else if (z <= z_up + D_eff) {
                                return 0;
                            } else {
                                return Math.PI * Ds;
                            }
                        }
                    }
                }
            }
        }
        
        // ====================== 方法四：Chance Technical Design Manual ======================
        function calculateMethod4() {
            const { n, Ds, Sh, L, Hh_bot, Dh } = pileParams;
            
            // 计算螺旋板位置
            const Hh = new Array(n);
            for (let idx = 0; idx < n; idx++) {
                Hh[idx] = L - (n - idx -1) * Sh - Hh_bot; // 从上到下
            }
            
            // 将土层参数转换为结构体数组
            const soil_layers = [];
            for (let i = 0; i < soilLayers.length; i++) {
                let soil_type_num;
                switch(soilLayers[i].soil_type) {
                    case 'clay': soil_type_num = 1; break;
                    case 'sand': soil_type_num = 2; break;
                    case 'mixed': soil_type_num = 3; break;
                    default: soil_type_num = 2; // 默认砂土
                }
                
                soil_layers.push({
                    depth_top: soilLayers[i].depth_top,
                    depth_bottom: soilLayers[i].depth_bottom,
                    soil_type_num: soil_type_num,
                    cohesion: soilLayers[i].c,
                    friction_angle: soilLayers[i].phi,
                    unit_weight: soilLayers[i].gamma,
                    undrained_shear_strength: soilLayers[i].Cu
                });
            }
            
            // 计算极限承载力
            const load_type = 'tension'; // 同时计算抗拉和抗压
            const result = ChanceModel(load_type, Hh, soil_layers);
            
            return {
                tension: result.Qu_tension.toFixed(2),
                compression: result.Qu_compression.toFixed(2),
                tension_details: `最大螺旋板荷载: ${result.Qu_h_max.toFixed(2)}kN`,
                compression_details: `桩底承载力: ${result.Q_base_compression.toFixed(2)}kN`,
                details: `侧摩阻力: ${result.Q_side_friction.toFixed(2)}kN, 安装类型: ${result.installation_type}`
            };
            
            // Chance方法计算函数
            function ChanceModel(load_type, Hh, soil_layers) {
                const n_helices = n;
                const Q_individual_tension = new Array(n_helices).fill(0);
                const Q_individual_compression = new Array(n_helices).fill(0);
                const installation_types = new Array(n_helices);
                
                // 计算各螺旋板承载力（抗拉和抗压）
                for (let i = 0; i < n_helices; i++) {
                    const B = Dh[i];
                    const D = Hh[i];
                    
                    // 确定螺旋板所在土层
                    let layer_idx = -1;
                    for (let j = 0; j < soil_layers.length; j++) {
                        if (D >= soil_layers[j].depth_top && D <= soil_layers[j].depth_bottom) {
                            layer_idx = j;
                            break;
                        }
                    }
                    
                    if (layer_idx === -1) {
                        // 使用最接近的土层
                        layer_idx = soil_layers.length - 1;
                    }
                    
                    const layer = soil_layers[layer_idx];
                    
                    // 确定桩底所在土层
                    let BaseLayer_idx = -1;
                    for (let j = 0; j < soil_layers.length; j++) {
                        if (L >= soil_layers[j].depth_top && L <= soil_layers[j].depth_bottom) {
                            BaseLayer_idx = j;
                            break;
                        }
                    }
                    
                    if (BaseLayer_idx === -1) {
                        BaseLayer_idx = soil_layers.length - 1;
                    }
                    
                    const BaseLayer = soil_layers[BaseLayer_idx];
                    
                    // 根据D/B判断安装类型
                    if (D / B >= 5) {
                        installation_types[i] = 'deep';
                    } else {
                        installation_types[i] = 'shallow';
                    }
                    
                    // 计算螺旋板投影面积（抗拉扣除桩身面积，抗压不扣除）
                    const A_h_tension = Math.PI * ((B/2) * (B/2) - (Ds/2) * (Ds/2));  // 抗拉：扣除桩底面积
                    const A_h_compression = Math.PI * ((B/2) * (B/2) - (Ds/2) * (Ds/2));  // 抗压：扣除桩底面积
                    const A_s = Math.PI * (Ds/2) * (Ds/2);  // 桩底面积
                    
                    // 根据土体类型选择叶片承载力（抗拉和抗压）的计算方法
                    switch (layer.soil_type_num) {
                        case 1: // 黏土
                            // 抗拉承载力
                            Q_individual_tension[i] = calculateClayCapacityTension(A_h_tension, D, B, layer, installation_types[i]);
                            // 抗压承载力
                            Q_individual_compression[i] = calculateClayCapacityCompression(A_h_compression, D, B, layer, installation_types[i]);
                            break;
                            
                        case 2: // 砂土
                            // 抗拉承载力
                            Q_individual_tension[i] = calculateSandCapacityTension(A_h_tension, D, B, layer, installation_types[i]);
                            // 抗压承载力
                            Q_individual_compression[i] = calculateSandCapacityCompression(A_h_compression, D, layer, installation_types[i]);
                            break;
                            
                        case 3: // 混合土
                            // 抗拉承载力
                            Q_individual_tension[i] = calculateMixedSoilCapacityTension(A_h_tension, D, B, layer, installation_types[i]);
                            // 抗压承载力
                            Q_individual_compression[i] = calculateMixedSoilCapacityCompression(A_h_compression, D, B, layer, installation_types[i]);
                            break;
                            
                        default:
                            // 默认按砂土处理
                            Q_individual_tension[i] = calculateSandCapacityTension(A_h_tension, D, B, layer, installation_types[i]);
                            Q_individual_compression[i] = calculateSandCapacityCompression(A_h_compression, D, layer, installation_types[i]);
                    }
                }
                
                // 根据土体类型选择桩底抗压承载力计算方法
                const bottom_layer_idx = soil_layers.length - 1;
                const bottom_layer = soil_layers[bottom_layer_idx];
                const A_s = Math.PI * (Ds/2) * (Ds/2);
                let Q_base_compression = 0;
                
                switch (bottom_layer.soil_type_num) {
                    case 1: // 黏土
                        Q_base_compression = calculateClayBaseCapacityCompression(A_s, L, Dh[n-1], bottom_layer, installation_types[n-1]);
                        break;
                    case 2: // 砂土
                        Q_base_compression = calculateSandBaseCapacityCompression(A_s, L, bottom_layer, installation_types[n-1]);
                        break;
                    case 3: // 混合土
                        Q_base_compression = calculateMixedSoilBaseCapacityCompression(A_s, L, Dh[n-1], bottom_layer, installation_types[n-1]);
                        break;
                }
                
                // 计算螺旋叶片上最大的荷载，用于叶片弯曲风险验算
                let Qu_h_max;
                if (load_type === 'tension') {
                    Qu_h_max = Math.max(...Q_individual_tension);
                } else {
                    Qu_h_max = Math.max(...Q_individual_compression);
                }
                
                // 计算桩身侧摩阻力（抗拉和抗压相同）
                const Q_side_friction = calculateSideFriction(soil_layers);
                
                // 总承载力 = 螺旋板承载力 + 侧摩阻力
                let Qu_tension_sum = 0;
                let Qu_compression_sum = 0;
                
                for (let i = 0; i < n_helices; i++) {
                    Qu_tension_sum += Q_individual_tension[i];
                    Qu_compression_sum += Q_individual_compression[i];
                }
                
                const Qu_tension = Qu_tension_sum + Q_side_friction;
                const Qu_compression = Qu_compression_sum + Q_side_friction + Q_base_compression;
                
                return {
                    Qu_tension: Qu_tension,
                    Qu_compression: Qu_compression,
                    Qu_h_max: Qu_h_max,
                    Q_side_friction: Q_side_friction,
                    Q_base_compression: Q_base_compression,
                    installation_type: installation_types[0]
                };
            }
            
            // 侧摩阻力计算函数
            function calculateSideFriction(soil_layers) {
                let Q_side = 0;
                
                // 忽略最底部1倍最大螺旋板直径范围内的侧摩阻力
                const exclusion_zone = Math.max(...Dh);
                const effective_length = Math.max(0, L - exclusion_zone);
                
                if (effective_length <= 0) {
                    return 0;
                }
                
                // 计算桩身周长
                const shaft_perimeter = Math.PI * Ds;
                
                // 按土层分段计算侧摩阻力
                for (let i = 0; i < soil_layers.length; i++) {
                    const layer = soil_layers[i];
                    
                    // 计算桩身在该土层中的长度
                    const layer_top = Math.max(layer.depth_top, exclusion_zone);
                    const layer_bottom = Math.min(layer.depth_bottom, L);
                    
                    const segment_length = Math.max(0, layer_bottom - layer_top);
                    
                    if (segment_length <= 0) {
                        continue;
                    }
                    
                    // 计算该土层中点深度处的单位侧摩阻力
                    const mid_depth = (layer_top + layer_bottom) / 2;
                    const f_s = calculateUnitSideResistance(layer, mid_depth);
                    
                    // 累加该土层的侧摩阻力
                    const Q_side_layer = f_s * shaft_perimeter * segment_length;
                    Q_side += Q_side_layer;
                }
                
                return Q_side;
            }
            
            function calculateUnitSideResistance(layer, depth) {
                switch (layer.soil_type_num) {
                    case 1: // 黏土
                        // 黏土 - Alpha方法
                        const s_u = layer.undrained_shear_strength;
                        
                        // API方法确定粘着系数α
                        const s_u_psf = s_u * 20.885; // kPa转换为psf
                        
                        let alpha;
                        if (s_u_psf < 500) {
                            alpha = 1.0;
                        } else if (s_u_psf > 1500) {
                            alpha = 0.5;
                        } else {
                            alpha = 1.0 - 0.5 * (s_u_psf - 500) / 1000;
                        }
                        
                        return alpha * s_u;
                        
                    case 2: // 砂土
                    case 3: // 混合土
                        // 砂土和混合土 - 基于表5-4的插值方法
                        const sigma_v = layer.unit_weight * depth; // 有效垂直应力 [kPa]
                        const sigma_v_psf = sigma_v * 20.885; // kPa转换为psf
                        
                        const phi = layer.friction_angle;
                        
                        // 使用表5-4进行插值计算
                        const f_s_psf = interpolateTable5_4(sigma_v_psf, phi);
                        return f_s_psf / 20.885; // psf转换为kPa
                        
                    default:
                        return 0;
                }
            }
            
           function interpolateTable5_4(sigma_v_psf, phi) {
    const sigma_vo_table = [500, 1000, 1500, 2000, 2500, 3000, 3500, 4000];
    const phi_table = [20, 25, 30, 35, 40];
    
    const fs_table = [
        [137,   175,   217,   263,   315],
        [273,   350,   433,   525,   629],
        [410,   524,   650,   788,   944],
        [546,   700,   866,   1050,  1259],
        [683,   875,   1082,  1313,  1574],
        [819,   1049,  1300,  1575,  1888],
        [956,   1244,  1516,  1838,  2203],
        [1092,  1399,  1732,  2101,  2517]
    ];
    
    // 限制输入参数在表格范围内
    const sigma_v_clamped = Math.max(Math.min(sigma_v_psf, 4000), 500);
    const phi_clamped = Math.max(Math.min(phi, 40), 20);
    
    // 找到sigma_v的索引区间
    let sigma_idx = 0;
    for (let i = 0; i < sigma_vo_table.length - 1; i++) {
        if (sigma_v_clamped >= sigma_vo_table[i] && sigma_v_clamped <= sigma_vo_table[i + 1]) {
            sigma_idx = i;
            break;
        } else if (sigma_v_clamped < sigma_vo_table[i]) {
            sigma_idx = i - 1;
            break;
        }
    }
    
    // 确保sigma_idx在有效范围内
    sigma_idx = Math.max(0, Math.min(sigma_idx, sigma_vo_table.length - 2));
    
    // 找到phi的索引区间
    let phi_idx = 0;
    for (let i = 0; i < phi_table.length - 1; i++) {
        if (phi_clamped >= phi_table[i] && phi_clamped <= phi_table[i + 1]) {
            phi_idx = i;
            break;
        } else if (phi_clamped < phi_table[i]) {
            phi_idx = i - 1;
            break;
        }
    }
    
    // 确保phi_idx在有效范围内
    phi_idx = Math.max(0, Math.min(phi_idx, phi_table.length - 2));
    
    // 获取四个角点的值
    const f11 = fs_table[sigma_idx][phi_idx];
    const f12 = fs_table[sigma_idx][phi_idx + 1];
    const f21 = fs_table[sigma_idx + 1][phi_idx];
    const f22 = fs_table[sigma_idx + 1][phi_idx + 1];
    
    // 计算插值权重
    const sigma_low = sigma_vo_table[sigma_idx];
    const sigma_high = sigma_vo_table[sigma_idx + 1];
    const phi_low = phi_table[phi_idx];
    const phi_high = phi_table[phi_idx + 1];
    
    const t_sigma = (sigma_v_clamped - sigma_low) / (sigma_high - sigma_low);
    const t_phi = (phi_clamped - phi_low) / (phi_high - phi_low);
    
    // 二维线性插值公式
    const f_result = 
        f11 * (1 - t_sigma) * (1 - t_phi) +
        f21 * t_sigma * (1 - t_phi) +
        f12 * (1 - t_sigma) * t_phi +
        f22 * t_sigma * t_phi;
    
    return f_result;
}
            
            // 抗拉承载力计算函数
            function calculateClayCapacityTension(A_h, D, B, layer, installation) {
                switch (installation) {
                    case 'shallow':
                        const F_c = Math.min(1.2 * D / B, 9);
                        return A_h * (layer.cohesion * F_c + layer.unit_weight * D);
                    case 'deep':
                        const N_c = 9; // 深层抗拉时使用N_c=9
                        return A_h * (layer.cohesion * N_c + layer.unit_weight * D);
                    default:
                        return 0;
                }
            }
            
            function calculateSandCapacityTension(A_h, D, B, layer, installation) {
                const phi_rad = layer.friction_angle * Math.PI / 180;
                
                switch (installation) {
                    case 'shallow':
                        const r = B / 2;
                        const R = r + D * Math.tan(phi_rad / 2);
                        const V = (Math.PI * D / 3) * (2 * r * r + R * R + 2 * r * R);
                        const W_s = layer.unit_weight * V;
                        const K_0 = 1 - Math.sin(phi_rad);
                        const lateral_term = Math.PI * layer.unit_weight * K_0 * Math.tan(phi_rad) *
                                           Math.pow(Math.cos(phi_rad / 2), 2) *
                                           (B * D * D / 2 + D * D * D * Math.tan(phi_rad / 2) / 3);
                        return W_s + lateral_term;
                    case 'deep':
                        const q_prime = layer.unit_weight * D;
                        const N_q = getBearingCapacityFactor(layer.friction_angle, 'deep');
                        return A_h * q_prime * N_q;
                    default:
                        return 0;
                }
            }
            
            function calculateMixedSoilCapacityTension(A_h, D, B, layer, installation) {
                const phi_rad = layer.friction_angle * Math.PI / 180;
                
                switch (installation) {
                    case 'shallow':
                        const r = B / 2;
                        const R = r + D * Math.tan(phi_rad / 2);
                        const V = (Math.PI * D / 3) * (2 * r * r + R * R + 2 * r * R);
                        const W_s = layer.unit_weight * V;
                        const K_0 = 1 - Math.sin(phi_rad);
                        const lateral_term = Math.PI * layer.unit_weight * K_0 * Math.tan(phi_rad) *
                                           Math.pow(Math.cos(phi_rad / 2), 2) *
                                           (B * D * D / 2 + D * D * D * Math.tan(phi_rad / 2) / 3);
                        const A_c = Math.PI * (R * R + r * r + Math.sqrt(Math.pow(R * R - r * r, 2) + Math.pow(D * (R + r), 2)));
                        return W_s + lateral_term + layer.cohesion * A_c;
                    case 'deep':
                        const q_prime = layer.unit_weight * D;
                        const N_c = 9;
                        const N_q = getBearingCapacityFactor(layer.friction_angle, 'deep');
                        return A_h * (layer.cohesion * N_c + q_prime * N_q);
                    default:
                        return 0;
                }
            }
            
            // 叶片抗压承载力计算函数
            function calculateClayCapacityCompression(A_h, D, B, layer, installation) {
                switch (installation) {
                    case 'shallow':
                        let N_c = 6.0 * (1 + 0.2 * D / B);
                        if (N_c > 9) N_c = 9;
                        return A_h * (layer.cohesion * N_c + layer.unit_weight * D);
                    case 'deep':
                        N_c = 9;
                        return A_h * (layer.cohesion * N_c + layer.unit_weight * D);
                    default:
                        return 0;
                }
            }
            
            function calculateSandCapacityCompression(A_h, D, layer, installation) {
                switch (installation) {
                    case 'shallow':
                        const q_prime = layer.unit_weight * D;
                        const N_q = getBearingCapacityFactor(layer.friction_angle, 'shallow');
                        return A_h * q_prime * N_q;
                    case 'deep':
                        const q_prime_deep = layer.unit_weight * D;
                        const N_q_deep = getBearingCapacityFactor(layer.friction_angle, 'deep');
                        return A_h * q_prime_deep * N_q_deep;
                    default:
                        return 0;
                }
            }
            
            function calculateMixedSoilCapacityCompression(A_h, D, B, layer, installation) {
                switch (installation) {
                    case 'shallow':
                        const q_prime = layer.unit_weight * D;
                        let N_c = 6.0 * (1 + 0.2 * D / B);
                        if (N_c > 9) N_c = 9;
                        const N_q = getBearingCapacityFactor(layer.friction_angle, 'shallow');
                        return A_h * (layer.cohesion * N_c + q_prime * N_q);
                    case 'deep':
                        const q_prime_deep = layer.unit_weight * D;
                        N_c = 9;
                        const N_q_deep = getBearingCapacityFactor(layer.friction_angle, 'deep');
                        return A_h * (layer.cohesion * N_c + q_prime_deep * N_q_deep);
                    default:
                        return 0;
                }
            }
            
            // 桩底抗压承载力计算函数
            function calculateClayBaseCapacityCompression(A_s, L, B, layer, installation) {
                switch (installation) {
                    case 'shallow':
                        let N_c = 6.0 * (1 + 0.2 * L / B);
                        if (N_c > 9) N_c = 9;
                        return A_s * layer.cohesion * N_c;
                    case 'deep':
                        N_c = 9;
                        return A_s * layer.cohesion * N_c;
                    default:
                        return 0;
                }
            }
            
            function calculateSandBaseCapacityCompression(A_s, L, layer, installation) {
                switch (installation) {
                    case 'shallow':
                        const q_prime = layer.unit_weight * L;
                        const N_q = getBearingCapacityFactor(layer.friction_angle, 'shallow');
                        return A_s * q_prime * N_q;
                    case 'deep':
                        const q_prime_deep = layer.unit_weight * L;
                        const N_q_deep = getBearingCapacityFactor(layer.friction_angle, 'deep');
                        return A_s * q_prime_deep * N_q_deep;
                    default:
                        return 0;
                }
            }
            
            function calculateMixedSoilBaseCapacityCompression(A_s, L, B, layer, installation) {
                switch (installation) {
                    case 'shallow':
                        const q_prime = layer.unit_weight * L;
                        let N_c = 6.0 * (1 + 0.2 * L / B);
                        if (N_c > 9) N_c = 9;
                        const N_q = getBearingCapacityFactor(layer.friction_angle, 'shallow');
                        return A_s * (layer.cohesion * N_c + q_prime * N_q);
                    case 'deep':
                        const q_prime_deep = layer.unit_weight * L;
                        N_c = 9;
                        const N_q_deep = getBearingCapacityFactor(layer.friction_angle, 'deep');
                        return A_s * (layer.cohesion * N_c + q_prime_deep * N_q_deep);
                    default:
                        return 0;
                }
            }
            
            // 承载力因子计算函数
            function getBearingCapacityFactor(phi, installation) {
                switch (installation) {
                    case 'shallow':
                        // 浅基础承载力因子
                        const phi_tab = [0, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48];
                        const Nq_tab = [1.0, 2.7, 3.3, 4.0, 4.9, 6.0, 7.4, 9.2, 11.4, 14.2, 17.8, 22.5, 28.5, 36.5, 47.2, 61.5, 81.3, 108.7, 147.7, 204.2, 287.8];
                        
                        // 线性插值
                        for (let i = 0; i < phi_tab.length - 1; i++) {
                            if (phi >= phi_tab[i] && phi <= phi_tab[i+1]) {
                                const t = (phi - phi_tab[i]) / (phi_tab[i+1] - phi_tab[i]);
                                return Nq_tab[i] + t * (Nq_tab[i+1] - Nq_tab[i]);
                            }
                        }
                        
                        // 如果超出范围，使用边界值
                        if (phi <= phi_tab[0]) return Nq_tab[0];
                        if (phi >= phi_tab[phi_tab.length-1]) return Nq_tab[Nq_tab.length-1];
                        return 20; // 默认值
                        
                    case 'deep':
                        // 深基础承载力因子
                        return 0.5 * Math.pow(12 * phi, phi / 54);
                        
                    default:
                        return 20;
                }
            }
        }
        
        // ====================== 方法五：IPENZ Practice Note 28 ======================
        function calculateMethod5() {
            const { n, Ds, Sh, L, Hh_bot, Dh } = pileParams;
            
            // 检查Dh数组长度是否与叶片数量n一致
            if (Dh.length !== n) {
                return {
                    tension: "参数错误",
                    compression: "参数错误",
                    tension_details: "叶片直径数组长度必须等于叶片数量",
                    compression_details: "叶片直径数组长度必须等于叶片数量",
                    details: "计算失败：叶片直径数组长度必须等于叶片数量"
                };
            }
            
            // 计算叶片位置
            const depths_blades = new Array(n);
            for (let idx = 0; idx < n; idx++) {
                depths_blades[idx] = L - (n - idx - 1) * Sh - Hh_bot; // 从上到下
            }
            
            const H_helix = depths_blades[0]; // 最上部叶片到桩顶的距离 (m)
            
            // 确定模式
            const Dh_mean = Dh.reduce((sum, val) => sum + val, 0) / Dh.length;
            const mode = Sh >= 3 * Dh_mean ? 'cylinder' : 'individual';
            
            // 构建土层参数
            const soil_types = soilLayers.map(layer => layer.soil_type);
            const gamma_eff = soilLayers.map(layer => layer.gamma);
            const phi = soilLayers.map(layer => layer.phi);
            const k = soilLayers.map(layer => layer.k);
            const Cu = soilLayers.map(layer => layer.Cu);
            
            // 计算承载力
            const Qc = NewZealandModel();
            
            return {
                tension: "N/A",
                compression: Qc.toFixed(2),
                tension_details: "该方法不计算抗拉承载力",
                compression_details: `模式: ${mode === 'cylinder' ? '圆柱剪切' : '单独承载'}`,
                details: `叶片数量: ${n}, 叶片间距: ${Sh}m, 平均直径: ${Dh_mean.toFixed(3)}m`
            };
            
            // 新西兰螺旋桩极限抗压承载力计算
            function NewZealandModel() {
                // 确定每个叶片所在的土层
                const blade_layers = new Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    let found = false;
                    for (let j = 0; j < soilLayers.length; j++) {
                        if (depths_blades[i] >= soilLayers[j].depth_top && depths_blades[i] <= soilLayers[j].depth_bottom) {
                            blade_layers[i] = j;
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        blade_layers[i] = soilLayers.length - 1;
                    }
                }
                
                // 计算各叶片处的垂直有效应力
                const sigma_v = new Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    sigma_v[i] = calculate_effective_stress(depths_blades[i]);
                }
                
                // 计算几何参数
                // 每个叶片的底面积（使用各自的直径）
                const Ah = new Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    Ah[i] = Math.PI * (Dh[i]/2) * (Dh[i]/2) - Math.PI * (Ds/2) * (Ds/2);
                }
                
                // 计算桩杆侧摩阻力的长度（距最上部叶片4Dh以上）
                let L_shaft = 0;
                if (H_helix > 4 * Dh_mean) {
                    L_shaft = H_helix - 4 * Dh_mean;
                }
                
                // 计算桩杆侧摩阻力
                let Qs = 0;
                
                if (L_shaft > 0) {
                    // 桩杆侧摩阻力计算范围
                    const shaft_top = 0;  // 桩顶
                    const shaft_bottom = L_shaft;  // 最上部叶片上方4Dh处
                    
                    // 分段计算桩杆在各土层中的长度和侧摩阻力
                    for (let layer = 0; layer < soilLayers.length; layer++) {
                        // 确定该土层在桩杆计算范围内的部分
                        const layer_in_shaft_top = Math.max(shaft_top, soilLayers[layer].depth_top);
                        const layer_in_shaft_bottom = Math.min(shaft_bottom, soilLayers[layer].depth_bottom);
                        
                        if (layer_in_shaft_bottom > layer_in_shaft_top) {
                            // 该土层在计算范围内的长度
                            const layer_length = layer_in_shaft_bottom - layer_in_shaft_top;
                            
                            // 该段中点深度处的有效应力
                            const layer_mid_depth = (layer_in_shaft_top + layer_in_shaft_bottom) / 2;
                            const sigma_v_layer = calculate_effective_stress(layer_mid_depth);
                            
                            // 该段桩杆侧表面积
                            const A_shaft_layer = Math.PI * Ds * layer_length;
                            
                            // 根据土质类型计算该段侧摩阻力
                            const soil_type = soilLayers[layer].soil_type;
                            if (soil_type === 'sand') {
                                const phi_rad = soilLayers[layer].phi * Math.PI / 180;
                                Qs += soilLayers[layer].k * sigma_v_layer * Math.tan(2/3 * phi_rad) * A_shaft_layer;
                            } else {  // clay或其他
                                const Cu_layer = soilLayers[layer].Cu;
                                if (Cu_layer > 0) {
                                    const alpha_layer = calculate_alpha_value(Cu_layer);
                                    Qs += alpha_layer * Cu_layer * A_shaft_layer;
                                }
                            }
                        }
                    }
                }
                
                // 计算不同模式的承载力
                if (mode === 'individual') {   // 单独承载模式
                    // 叶片端阻力 Qh
                    let Qh = 0;
                    for (let i = 0; i < n; i++) {
                        const soil_type = soilLayers[blade_layers[i]].soil_type;
                        if (soil_type === 'sand') {
                            // 砂土：计算Nq
                            const Nq_i = calculate_Nq_value(soilLayers[blade_layers[i]].phi);
                            Qh += sigma_v[i] * Nq_i * Ah[i];
                        } else {  // clay或其他
                            // 粘土：计算Nc
                            const Nc_i = calculate_Nc_value(depths_blades[i], Dh[i]);
                            Qh += Nc_i * soilLayers[blade_layers[i]].Cu * Ah[i];
                        }
                    }
                    
                    // 总承载力
                    return Qs + Qh;
                    
                } else if (mode === 'cylinder') {   // 圆柱剪切模式
                    // 圆柱体参数
                    const H_cylinder = depths_blades[n-1] - depths_blades[0];   // 圆柱体高度
                    const D_cylinder = Dh_mean;  // 圆柱体直径取平均叶片直径
                    
                    // 计算圆柱体侧摩阻力（分段计算不同土层）
                    let Qf_cylinder = 0;
                    const cylinder_top = depths_blades[0];
                    const cylinder_bottom = depths_blades[n-1];
                    
                    for (let layer = 0; layer < soilLayers.length; layer++) {
                        // 确定该土层在圆柱体范围内的部分
                        const layer_in_cylinder_top = Math.max(cylinder_top, soilLayers[layer].depth_top);
                        const layer_in_cylinder_bottom = Math.min(cylinder_bottom, soilLayers[layer].depth_bottom);
                        
                        if (layer_in_cylinder_bottom > layer_in_cylinder_top) {
                            // 该土层在圆柱体内的长度
                            const layer_length = layer_in_cylinder_bottom - layer_in_cylinder_top;
                            
                            // 该段中点深度处的有效应力
                            const layer_mid_depth = (layer_in_cylinder_top + layer_in_cylinder_bottom) / 2;
                            const sigma_v_layer = calculate_effective_stress(layer_mid_depth);
                            
                            // 该段圆柱体侧表面积
                            const A_cylinder_layer = Math.PI * D_cylinder * layer_length;
                            
                            // 根据土质类型计算该段侧摩阻力
                            const soil_type = soilLayers[layer].soil_type;
                            if (soil_type === 'sand') {
                                const phi_rad = soilLayers[layer].phi * Math.PI / 180;
                                Qf_cylinder += soilLayers[layer].k * sigma_v_layer * Math.tan(phi_rad) * A_cylinder_layer;
                            } else {  // clay或其他
                                const Cu_layer = soilLayers[layer].Cu;
                                if (Cu_layer > 0) {
                                    const alpha_layer = calculate_alpha_value(Cu_layer);
                                    Qf_cylinder += alpha_layer * Cu_layer * A_cylinder_layer;
                                }
                            }
                        }
                    }
                    
                    // 圆柱体端阻力（取最底部叶片）
                    const soil_type_last = soilLayers[blade_layers[n-1]].soil_type;
                    let Qb_cylinder = 0;
                    
                    if (soil_type_last === 'sand') {
                        // 使用给定公式计算Nq
                        const Nq_last = calculate_Nq_value(soilLayers[blade_layers[n-1]].phi);
                        Qb_cylinder = sigma_v[n-1] * Nq_last * Ah[n-1];
                    } else {  // clay或其他
                        const Nc_last = calculate_Nc_value(depths_blades[n-1], Dh[n-1]);
                        Qb_cylinder = Nc_last * soilLayers[blade_layers[n-1]].Cu * Ah[n-1];
                    }
                    
                    // 总承载力
                    return Qs + Qf_cylinder + Qb_cylinder;
                    
                } else {
                    return 0;
                }
            }
            
            // 子函数：计算任意深度处的有效应力
            function calculate_effective_stress(z) {
                let sigma_v = 0;
                for (let i = 0; i < soilLayers.length; i++) {
                    if (z > soilLayers[i].depth_top) {
                        const layer_thickness = Math.min(z, soilLayers[i].depth_bottom) - soilLayers[i].depth_top;
                        if (layer_thickness > 0) {
                            sigma_v += soilLayers[i].gamma * layer_thickness;
                        }
                    } else {
                        break;
                    }
                }
                return sigma_v;
            }
            
            // 子函数：计算黏聚系数α
            function calculate_alpha_value(Cu) {
                // 根据规范：当Cu ≤ 25 kPa时，α = 1.0；当Cu ≥ 70 kPa时，α = 0.5；中间线性插值
                if (Cu <= 25) {
                    return 1.0;
                } else if (Cu >= 70) {
                    return 0.5;
                } else {
                    return 1.0 - 0.5 * (Cu - 25) / (70 - 25);
                }
            }
            
            // 子函数：计算砂土承载力系数Nq
            function calculate_Nq_value(phi_deg) {
                // 使用给定公式计算砂土承载力系数Nq
                const phi_rad = phi_deg * Math.PI / 180;
                return Math.exp(Math.PI * Math.tan(phi_rad)) * Math.pow(Math.tan(Math.PI/4 + phi_rad/2), 2);
            }
            
            // 子函数：计算粘土承载力系数Nc
            function calculate_Nc_value(z, D) {
                // 根据深径比(D/B)计算Nc
                const D_B = z / D;
                
                if (D_B <= 2.5) {
                    return 9.0;
                } else if (D_B < 8) {
                    return 9.0 + 0.4 * (D_B - 2.5);
                } else {
                    return 11.2; // 最大值
                }
            }
        }
    </script>
</body>
</html>